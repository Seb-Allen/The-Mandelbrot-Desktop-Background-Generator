# The-Mandelbrot-Desktop-Background-Generator
My final project for Code in Place 2021 saves a desktop background that has been generated by iterating the Mandelbrot function.

I learnt about the Mandelbrot set during a lecture called 'The Art of Code' that I watched at the start of Code In Place 2021!
I enjoyed the lecture a lot, but struggled to understand many concepts because I had no experience of coding yet.
Rewatching the lecture now that Code In Place lessons have come to end, I really appreciate just how far we've all come in such a short time!

The decision to code the Mandelbrot set was borne out of nothing more than a want to do so! It's an intricate and beautiful shape. In fact, it's infinitely intricate, and is created by a remarkably simple function. While the function itself is simple, it was certainly a challenge to understand the underlying mathematical principles of complex, real and imaginary numbers, as well as how to correctly iterate the function before attempting to assimilate it into code.

The Mandelbrot set is a set of complex numbers that when passed into a particular function and iterated, do not tend towards infinity. Plotting these complex numbers on a graph shows the boundary of which numbers will tend towards infinity, and which remain bounded. To understand more, let's look at the function:

            f(z) = z ** 2 + C

To decide which numbers are included in the Mandelbrot set, we determine the behaviour of 0 under iteration of f, for a given complex number, C:

            C = a + bi

    whereby a and b are real numbers, and i is an imaginary number that satisfies the equation:

            i ** 2 = -1

In mathematics, we cannot multiply any two identical numbers to give a minus result, and so we simply create an imaginary number, 'i', that satisfies the equation. This is interesting, because while it may appear to be an invented convenience that cannot exist, we can prove that it does exist and is 'real'. In fact, this program will attempt to prove that imaginary numbers are 'real'!

Before we attempt to prove this, let's delve a little deeper into our function. As mentioned, we are interested in how 0 behaves when z = 0, for a given C. There are two possible behaviours of z when we iterate the function for a particular value of C:

    1) the distance from 0 (magnitude) of the sequence gets arbitrarily large, i.e., it tends towards infinity.
    2) the distance from 0 is bounded, in fact, the distance never gets any larger than absolute 2.

Let's try this out using a couple of examples:

    When C = 1:

        f(0) = 0 ** 2 + 1 = 1
        f(1) = 1 ** 2 + 1 = 2
        f(2) = 2 ** 2 + 1 = 5
        f(5) = 5 ** 2 + 1 = 26
        f(26) = 26 ** 2 + 1 = 677

    We can see quite clearly that when C = 1, and we iterate our function to find the behaviour of 0, represented by z, that the
    sequence gets arbitrarily large.

    When C = -1:

        f(0) = 0 ** 2 - 1 = -1
        f(-1) = -1 ** 2 - 1 = 0
        f(0) = 0 ** 2 - 1 = -1
        f(-1) = -1 ** 2 - 1 = 0

    In this case, when C = -1, the distance from 0 is bounded. This example shows us that different values of C can exhibit dramatically
    different behaviour when iterated through our function.

That's great, but how do we get from this function to drawing a cool shape that has an infinitely long boundary, and infinite complexity?

Well, remember that C represents a complex number, in other words, a number that is made up of a real part, and an imaginary part. And because it has two parts, we essentially have a set of coordinates! But how can an imaginary number be plotted on a graph?! Well, it can't, at least not on the typical sort of graph we're familiar with, with a horizontal 'x' axis, and a vertical 'y' axis (also known as the Cartesian Plane). Instead, we plot these complex numbers on the Complex Plane that consists of a horizontal Real number axis, and a vertical Imaginary axis. 

In our Python program, we start by generating a blank canvas. We can recall that an image is a big collection of pixels, and one of the properties of pixels is that they each have a specified coordinate. So, we can take a particular pixel, look up it's coordinates, and convert those real number coordinates into a complex number that can be iterated in the Mandelbrot function. And setting z to 0 now fulfils the parameters we need in order to iterate the function.

We can test whether the complex number, C, derived from the coordinate of a specified pixel, alters the behaviour of the function so that it tends towards infinity, or it is bounded and therefore included in the Mandelbrot Set.

When looking at the code, we set two conditions for the Mandelbrot function:
    1) The function will iterate up to the number of iterations specified (which must be larger than 2).
    2) z can never be larger than absolute 2.

The function then counts the number of times each value of C successfully iterates through the function, by looping through each pixel, and returns the count. The count is then used to determine what colour the pixel should be. Presently, the colour scheme is greyscale only. If the count is  fewer than the number of specified iterations, then the relationship between iterations and count is scaled to 255 (i.e., the RGB colour scheme). For all other counts for the values of C, the pixel is set to black. This means that the Mandelbrot set will appear completely black, with it's edge highlighted by white and fading again to black as we move outwards in magnitude.

Finally, we then have the option to save the background image to the same directory the program is running in, as well as saving any custom parameters for later. Alternatively, parameters can easily be added, or edited, in the PARAMETERS.json file which the program will read. Likewise, for repeat use, custom screen resolutions may be manually entered in the SCREEN_RESOLUTIONS dictionary.
